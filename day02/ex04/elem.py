class Elem:

	# A constructor that can take as parameter the name of the element, its attributes
	# HTML, its contents, and the type of element (single or double tags).
	def __init__(self, nameElement, attributesHTML, contents, typeElement):
		pass

	def __str__(self):
		return ("html")

	def add_content(self):
		pass

def testMain():
	pass

if __name__ == '__main__':
    testMain()

    Теперь, когда у вас есть машина для приготовления кофе, у вас действительно нет
нужен ему ... Так ты его уничтожишь.
Затем вам откроется святой IGNUcius, который сделает вас откровением:
«HTML-элементы имеют более или менее одну и ту же структуру (тег,
контент, атрибуты). Было бы разумно реализовать класс, способный объединить
все эти общие поведения и особенности для
использовать силу наследования в Python, чтобы легко и просто получить
этот класс, не переписывая все. "


Именно тогда St. IGNUcius видит Mac, над которым вы работаете. Испугавшись,
он бежит, не давая вам подробностей, оставляя только файл тестов.
Без колебаний вы осознаете класс Elem со следующими характеристиками:


Конструктор, который может принимать в качестве параметра имя элемента, его атрибуты
HTML, его содержимое и тип элемента (одиночные или двойные теги).


Метод __str __ () возвращает HTML элемента.

Метод add_content () для добавления элементов в конец содержимого.


Если вы хорошо выполняете свою работу, вы сможете представлять любые
HTML-элемент и его содержимое с вашим классом Elem. Домашний стрейч:

файл tests.py, указанный в тематическом архиве, должен работать правильно
(нет ошибки утверждения, выход теста явно объявляет его
успех).

Очевидно, что мы недостаточно жестоки, чтобы тестировать функции
которые явно не заявлены в этом упражнении.

Ха-ха-ха ... Нет, мы не уверены, уверяю вас.


Вам также необходимо воспроизвести и отобразить следующую структуру, используя
Класс Elem: